Deca: a functional, object-oriented, generic systems programming language
by Eli Gottlieb, copyright 2010

-------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------

Deca is a language designed to provide the advanced features of sophisticated, high-level programming languages while still programming as close as possible to the bare metal.  It brings in the functional, object-oriented, and generic programming paradigms without requiring a garbage collector or a threading system, so programmers really only pay in performance for the features they use.

Deca provides first-class functions, lambdas, lexical closures to support functional programming.  It provides an object system in the style of CLOS, with generic functions and multimethods operating on records that can inherit, and its structural typing makes tuples part of the object system.  It provides generic programming type inference (including inferring that a pointer cannot be null) while still allowing elegant, convenient type annotations, which can be used in a form of type-based pattern matching.  Region-based memory management is used in place of garbage collection to support data of dynamic lifetime, though one-time definition of regions can be used to create region-allocated data structures on the stack.

Deca treats objects as first-class constructs not by making everything an object or forcing the programmer to define everything as a class, but by integrating classes into the type system as one type hierarchy among many.  Enumerated types, subranges, and exceptions can all subtype each other alongside classes, and this means that programmers can write pattern-matching expressions or even generic functions and methods that specialize on these types as well as on objects.

-------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------

decac is Deca's compiler, written as a frontend compiler invoking LLVM (http://www.llvm.org).  It is written in Scala (http://www.scala-lang.org), with a parser in Java generated by SableCC (http://sablecc.org) from the grammar file deca.scc.  Its build system is based, currently, on Apache Ant (http://ant.apache.org), although the Java bindings I wrote for LLVM compile in their own fashion.

The entire thing is a work-in-progress right now, but I can safely say that (subject to a refutation of my proof that Deca's type inference always terminates) the type system and type inference are done.  I can also safely say that the syntactic grammar is likely to change for the better and clearer as I find ways of eliminating the ambiguities that arise from attempting to simplify it.

To compile decac, run:
$ ant build_parser
$ ant build_llvm_bindings
$ and build

The parser need only be rebuilt when deca.scc has been altered, and building the LLVM Java bindings once ever should be enough until LLVM updates their ABI/API.

Happy hacking!
--Eli Gottlieb
